// 7 Движение
/*
-------------Пример 7-1 Частота кадров
 Processing “прокручивает” код в блоке draw() 60 раз в секунду для создания
 плавного движения. Чтобы убедиться в этом, запустите программу и
 понаблюдайте за значениями на консоли. Переменная frameRate контролирует
 скорость выполнения программы.
 */

//viod draw(){
//  println(rameRate);
//}

/*
--------------Пример 7-2 Устанавливаем частоту кадров
 Функция frameRate() изменяет скорость выполнения программы. В следующей
 программе удалите знаки // и оцените результат:
 */
//PImage img;
//PImage img1;

//void setup() {
//  size(480, 480);
//  img = loadImage("qwerty.jpeg");

//  img1 = loadImage("qwerty1.jpg");
//  //frameRate(30); // 30 кадров в секунду
//  //frameRate(12); // 12 кадров в секунду
//  //frameRate(2); // 2 кадра в секунду
//  frameRate(0.5); // 1 кадр каждые 2 секунды
//}

//void draw() {
//  image(img, 0, 0);
//  image(img1,240,0);
//  println(frameRate);

//}
//---------------------Пример 7-3: Передвигаем фигуру------стр 106

//int radius = 40;
//float x = -radius;
//float speed = 0.5;

//void setup() {
//  size(240, 120);
//  ellipseMode(RADIUS);
//}

//void draw() {
//  background(0);
//  x += speed; // Increase the value of x
//  arc(x, 60, radius, radius, 0.52, 5.76);
//}

/*
Когда вы запустите этот код, вы заметите, что фигура выходит за правую
 границу окна, когда значение переменной x превышает его ширину.
 Величина x по-прежнему растет, но фигура уже не видна.
 */

//------------------Пример 7-4: Разворот------------стр 107

//int radius = 40;
//float x = -radius;
//float speed = 0.5;

//void setup() {
//  size(240, 120);
//  smooth();
//  ellipseMode(RADIUS);
//}

//void draw(){
//  background(0);
//  x += speed;                        // Увеличение x
//  if (x > width + radius) {           // Если фигура вышла за край окна
//    x = -radius;                      // она возвращается к левому краю
//  }
//  arc(x, 60, radius, radius, 0.52, 5.76);
//}


//----------------Пример 7-5 Фигура отскакивает от стенки

//int radius = 40;
//float x = 110;
//float speed = 0.5;
//int direction = 1;

//void setup() {
//  size(240, 120);
//  ellipseMode(RADIUS);
//}

//void draw() {
//  background(0);
//  x += speed * direction;
//  if ((x > width-radius) || (x < radius)) { // если приближаемся к правому краю или к левому
//    direction = -direction; // Flip direction направление
//  }
//  if (direction == 1) { //статическое состояние фигуры..начальное условие
//    arc(x, 60, radius, radius, 0.52, 5.76);  // Фигура смотрит вправо
//  } else { // иначе положение противоположное
//    arc(x, 60, radius, radius, 3.67, 8.9); // Фигура смотрит влево
//  }
//}


//-----------Пример 7-6: Вычисляем промежуточные позиции----------

//int startX = 20;// Координата x начальной точки
//int stopX = 160;// Координата x конечной точки
//int startY = 30; // Координата y начальной точки
//int stopY = 80; // Координата y конечной точки
//float x = startX; // Текущая координата x
//float y = startY; // Текущая координата y
//float step = 0.005;// Величина шага (от 0.0 до 1.0)
//float pct = 0.0;// Доля от пройденного расстояния (от 0.0 до 1.0)

//void setup() {
//  size(240, 120);
//}

//void draw() {
//  background(0);
//  if (pct < 1.0) {
//    x = startX + ((stopX-startX) * pct);
//    y = startY + ((stopY-startY) * pct);
//    pct += step;
//  }
//  ellipse(x, y, 20, 20);
//}

//------------------------Пример 7-7: Генерируем случайные числа.----------------
/*В следующем примере программа генерирует случайные числа и выводит их на
 консоль. Диапазон значений определяется позицией мыши. Функция random()
 всегда возвращает числа типа float, поэтому убедитесь, что переменная слева
 от оператора присвоения имеет тип float, как в этом примере:
 */
//void draw() {
//float r = random(0, mouseX);
//println(r);
//}


//--------------Пример 7-8: Беспорядочное движение---------------
/*Этот пример основан на примере 7-7, функция random() используется для
 изменения позиции линий на экране. Когда курсор находится в левой части
 окна, движение почти незаметно; по мере продвижения вправо диапазон
 случайных чисел, генерируемых функцией random(), увеличивается и линии
 двигаются с большим размахом. Функция random() заключена в блоке for и в
 каждой строке вычисляются новые координаты линий:
 */

//void setup() {
//  size(240, 120);
//}

//void draw() {
//  background(204);
//  for (int x = 20; x < width; x += 20) {
//    float mx = mouseX / 10;
//    float offsetA = random(-mx, mx);
//    float offsetB = random(-mx, mx);
//    line(x + offsetA, 20, x - offsetB, 100);
//  }
//}

//-----------------Пример 7-9: Программируем беспорядочное движение-----------
/*Генератор случайных чисел можно использовать для создания более
 естественного движения фигур на экране. В следующем примере для изменения
 позиции круга на экране использованы случайные числа. Функция background()
 не включена в блок draw(), поэтому мы можем наблюдать траекторию
 движения фигуры:
 */

//float speed = 2.5;
//int diameter = 20;
//float x;
//float y;

//void setup() {
//  size(240, 120);
//  x = width/2;
//  y = height/2;
//}

//void draw() {
//  x += random(-speed, speed);
//  y += random(-speed, speed);
//  ellipse(x, y, diameter, diameter);
//}
/*
Сделав эти изменения в блоке draw(), вы сможете быть
 уверены, что круг останется в окне:
 void draw() {
 x += random(-speed, speed);
 y += random(-speed, speed);
 x = constrain(x, 0, width);
 y = constrain(y, 0, height);
 ellipse(x, y, diameter, diameter);
 }
 */
/*---------randomSeed()------
 
 Задает начальное значение для функции random().
 По умолчанию функция random() выдает разные результаты
 при каждом запуске программы. Установите для начального
 параметра значение константы, чтобы возвращать одни и
 те же псевдослучайные числа при каждом запуске программы.
 
 */

//-------------Пример 7-10: Длительность работы программы------------

/*
Processing всегда отсчитывает время, прошедшее с запуска программы. Оно
 измеряется в миллисекундах (одна тысячная секунды); так, после секунды
 работы программы счетчик досчитает до 1000, после 5 сукунд - до 5000, после
 минуты - до 60000. Счетчик Processing удобно использовать для запуска
 анимированных фигур в определенное время. Функция millis() возвращает
 значение этого счетчика.
 */

//void draw() {
//int timer = millis();
//println(timer);
//}

//---------------Пример 7-11: Запуск в заданный момент времени---------

/*
В комплекте в оператором if значения из millis() можно использовать для запуска
 событий в определенном порядке. Например, вы можете запустить код в блоке if
 через 2 секунды. В следующем примере время изменения переменной x задается
 переменными time1 и time2
 */

//int time1 = 2000;
//int time2 = 4000;
//float x = 0;
//void setup() {
//size(480, 120);
//smooth();
//}
//void draw() {
//int currentTime = millis();
//background(204);
//if (currentTime > time2) {
//x -= 0.5;
//} else if (currentTime > time1) {
//x += 2;
//}
//ellipse(x, 60, 90, 90);
//}

/*
На рисунке 7-2 изображена функция синус по отношению к углу. Обратите
 внимание, как изменяется синус по оси ординат в верхней и нижней частях
 волны, как он замедляется, а затем изменяет направление. Именно это
 качество кривой позволяет создать интересную траекторию движения.
 
 Синус и косинус угла в Processing находятся в диапазоне от -1 до 1. Как и в
 функции arc(), углы следует задавать в радианах (см. пример 3-7 и 3-8 в
 качестве напоминания). При рисовании траекторий мы обычно умножаем
 числа типа float, которые возвращают функции sin() и cos() на некоторую
 величину.
 */

//------------------Пример 7-12: Синус---------------------------

/*В этом примере мы покажем, как функция синус изменяется в диапазоне от -1 до
 1 с увеличением угла. Вы можете установить другой диапазон значений синуса,
 записав число от 0 до 255 в функцию map(). Мы используем эту величину для
 программирования цвета фона в окне:
 */
//float angle = 0.0;
//void draw() {
//  float sinval = sin(angle);
//  println(sinval);
//  float gray = map(sinval, -1, 1, 0, 255);
//  background(gray);
//  angle += 0.1;
//}


//-----------------Пример 7-13: Движение по синусоидальной траектории------------


//float angle = 0.0;
//float offset = 60;
//float scalar = 40;
//float speed = 0.05;

//void setup() {
//  size(240, 120);
//  smooth();
//}

//void draw() {
//  background(0);
//  float y1 = offset + sin(angle) * scalar;
//  float y2 = offset + sin(angle + 0.4) * scalar;
//  float y3 = offset + sin(angle + 0.8) * scalar;

//  ellipse( 80, y1, 40, 40);
//  ellipse(120, y2, 40, 40);
//  ellipse(160, y3, 40, 40);
  
//  angle += speed;
//}

//---------------Пример 7-14: Движение по кругу-------------

/*
Для создания движения по кругу нужны функции sin() и cos(). x-координата
изменяется по функции cos(), y-координата - по функции sin(). Обе функции
умножены на переменную scalar для регулировки радиуса движения и
суммированы с величиной, определяющей центр вращения:
*/
//float angle = 0.0;
//float offset = 60;
//float scalar = 30;
//float speed = 0.05;
//void setup() {
//size(120, 120);
//smooth();
//}
//void draw() {
//float x = offset + cos(angle) * scalar;
//float y = offset + sin(angle) * scalar;
//ellipse( x, y, 40, 40);
//angle += speed;
//}

//--------------------Пример 7-15: Спирали--------------
/*
Сделаем небольшое изменение в программе, чтобы переменная scalar
увеличивалась со временем, и получим спираль вместо окружности:
*/

float angle = 0.0;
float offset = 240;
float scalar = 2;
float speed = 0.05;
void setup() {
size(480, 480);
fill(0);
smooth();
}
void draw() {
float x = offset + cos(angle) * scalar;
float y = offset + sin(angle) * scalar;
ellipse( x, y, 2, 2);
angle += speed;
scalar += speed;
}
