// -------------rotate()------ex 06 03------- поворот----------

/*

  Поворачивает фигуру на величину, указанную параметром angle.
  Углы должны быть указаны в радианах (значения от 0 до TWO_PI)
 или преобразованы в радианы с помощью функции radians().

Объекты всегда поворачиваются вокруг своего положения относительно 
начала координат, а положительные числа вращают объекты по часовой 
стрелке. Преобразования применяются ко всему, что происходит после,
и последующие вызовы функции накапливают эффект. Например, вызов 
rotate(HALF_PI), а затем rotate(HALF_PI) - это то же самое, что и 
rotate(PI) . Все преобразования сбрасываются, когда draw() 
запускается снова.

Технически rotate() умножает текущую матрицу преобразования на 
матрицу вращения. Этой функцией можно дополнительно управлять с 
помощью PushMatrix() и PopMatrix().

*/


//void setup() {
//  size(120, 120);
//}

//void draw() {
//  rotate(mouseX / 100.0);
//  rect(40, 30, 160, 20);
//}

//size(400, 400);
//translate(width/2, height/2);
//rotate(PI/3.0);
//rect(-104, -104, 208, 208);

/*
Синтаксис
          rotate(angle)  
Параметры
          angle  (float)  угол поворота, указанный в радианах
Возврат
          void
*/


//--------------ex 06 04---------------------------
//void setup() {
//  size(120, 120);
//}

//void draw() {
//  rotate(mouseX / 100.0);
//  rect(-80, -10, 160, 20);
//}


//------------ex 06 05-------------
//float angle = 0;

//void setup() {
//  size(360, 360);
//  smooth();
//}

//void draw() { // с каждым циклом draw значение угла прирастает на 0.1 радиан
//  translate(mouseX, mouseY);
//  rotate(angle);
//  rect(-15, -15, 30, 30);
//  angle += 0.1;
//}


//-------------ex 06 06---------------------------
//float angle = 0.0;

//void setup() {
//  size(640, 640);
//}

//void draw() {
//  rotate(angle);
//  translate(mouseX, mouseY);
//  rect(-15, -15, 30, 30);
//  angle += 0.1;
//}


//-----------ex 06 07--------------
/*float angle = 0.0;
float angleDirection = 1;
float speed = 0.005;


void setup() {
  size(360, 360);
}

void draw() {
  background(204);
  translate(mouseX, mouseY); // Move to start position
  rotate(angle);
  strokeWeight(12);
  line(0, 0, 40, 0);
  translate(40, 0);  // Move to next joint
  rotate(angle * 2.0);
  strokeWeight(6);
  line(0, 0, 30, 0);
  translate(30, 0);  // Move to next joint
  rotate(angle * 2.5);
  strokeWeight(3);
  line(0, 0, 20, 0);
  angle += speed * angleDirection;
  if ((angle > QUARTER_PI) || (angle < 0)) {
    angleDirection = -angleDirection; // что то подобное YouTube 
  //качели             //5.4: Boolean Variables - Processing Tutorial
  }
}
*/

//-------------ex 06 08 ------------------

/*
Описание
Увеличивает или уменьшает размер фигуры путем 
расширения и сжатия вершин. Объекты всегда масштабируются 
от их относительного начала координат до системы координат.
Значения шкалы задаются в виде десятичных процентов. Например, 
вызов функции scale(2.0) увеличивает размер фигуры на 200%.

Преобразования применяются ко всему, что происходит после, и 
последующие вызовы функции умножают эффект. Например, 
вызов scale(2.0), а затем scale(1.5) совпадает с вызовом scale(3.0).
Если scale() вызывается в draw() , преобразование сбрасывается, 
когда цикл начинается снова. Использование этой функции 
с параметром z требует использования P3D в качестве параметра
для size(), как показано в третьем примере выше. 
Этой функцией можно дополнительно управлять с помощью
PushMatrix() и PopMatrix().

size(400, 400);
rect(120, 80, 200, 200);
scale(0.5);
rect(120, 80, 200, 200);
------------------------
size(400, 400);
rect(120, 80, 200, 200);
scale(0.5, 1.3);
rect(120, 80, 200, 200);
--------------------------
// Для масштабирования в 3D требуется P3D 
// в качестве параметра для size()
size(400, 400, P3D);
noFill();
translate(width/2+48, height/2);
box(80, 80, 80);
scale(2.5, 2.5, 2.5);
box(80, 80, 80);

Синтаксис
          scale(s)  
          scale(x, y)  
          scale(x, y, z)  
-----------------------------          
Параметры

s  (float)  процент для масштабирования объекта
x  (float)  процентное значение для масштабирования объекта по оси x
y  (float)  процентное значение для масштабирования объекта по оси y
z  (float)  процентное значение для масштабирования объекта по оси z
---------------------
Возврат
        void  

*/
//void setup() {
//  size(640, 640);
//}

//void draw() {
//  translate(mouseX, mouseY);
//  scale(mouseX / 60.0);
//  rect(-15, -15, 30, 30); // -15 --- это смещение координаты начала 
                            //отрисовки внутрь объекта rect
//}

//-------------------ex 06 09-----------
//void setup() {
//  size(120, 120);
//}

//void draw() { 
//  translate(mouseX, mouseY);
//  float scalar = mouseX / 60.0;
//  scale(scalar);
//  strokeWeight(1.0 / scalar);
//  rect(-15, -15, 30, 30);
//}
///*
//Скаля́р (от лат. scalaris — ступенчатый) — величина, 
//полностью определяемая в любой координатной системе одним числом или
//функцией, которое не изменяется при изменении пространственной системы 
//координат.
//*/

//-------------ex 06 10 --------------

/*
Помещает текущую матрицу преобразования в стек матриц. 
Понимание PushMatrix() и PopMatrix() требует понимания концепции стека матриц.

!!!Функция PushMatrix() сохраняет текущую систему координат в стеке,

!!!а PopMatrix() восстанавливает предыдущую систему координат.

PushMatrix() и PopMatrix() используются совместно с другими функциями 
преобразования и могут быть встроены для управления областью преобразований.
*/
//--------мое понимание--------------
// PushMatrix() -- типа верх стакана
// PopMatrix()---типа дно
// а весь стакан это типа стек матриц

/*
size(400, 400);

fill(255);
rect(0, 0, 200, 200);  // White rectangle

pushMatrix();
translate(120, 80);
fill(0);  
rect(0, 0, 200, 200);  // Black rectangle
popMatrix();

fill(100);  
rect(60, 40, 200, 200);  // Gray rectangle
*/

/*
          Синтаксис
                    pushMatrix()  
          Возврат
                    void
*/
void setup() {
  size(120, 120);
}

void draw() {
  pushMatrix();
  translate(mouseX, mouseY);
  rect(0, 0, 30, 30);
  popMatrix();
  translate(35, 10);
  rect(0, 0, 15, 15);
}
